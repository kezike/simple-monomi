6.830 Lab 2 Write-Up

For lab 2, I more-or-less followed the standard instructions for each section. However, there were some parts with subtleties that stumped for some time. These will be referenced below, where I outline my approach for each section:
- Predicate: This class was pretty straightforward, but one aspect of it that stumped me for a bit was the semantics of the compare function. For some time, I thought that the expectation was to call compare on the received tuple and to input the operand as an argument to this function. Apparently, the reverse was expected.
- JoinPredicate: Understanding the semantics of Predicate, JoinPredicate was not bad.
- Filter: The core essence of this class is to feed tuples that obey a given predicate. This involved iterating through tuples of the underlying child OpIteratorand passing in those tuples that obey said predicate.
- Join: The core logic of this class is the nested-loop join. The idea is to emit tuples that meet the join condition specified by the underlying JoinPredicate. This idea is not very sophisticated; after all, it is the brute-force join algorithm. However, I found that I had a small bug in my logic where I advanced the outer loop iterator prematurely. I was eventually able to debug this.
- IntegerAggregator: This core logic of this class was mergeTupleIntoGroup. This was quite a meety function, because it needs to setup the proper TupleDesc structure of the underlying iterator based on whether grouping is to be incorporated into the aggregation. It also needs to handle each of the operations. I was originally thinking of creating separate functions for each operation, until I realized that the meat of the function would be the same and I couldn't bring myself to terms with the redundancy. One aspect of this function that fooled me the most was the AVG operation. I realized soon enough that I would need a separate hash map for keeping track of the amount of objects encountered thus far. However, it took much longer for me to realie that I would also need a hash map for keeping track of the cumulative sum of values per group. Otherwise, the calculation of would be inaccurate due to integer division.
- StringAggregator: This class was essentially a subset of the logic in IntegerAggregator, since StringAggregators can only handle COUNT operations.
- Aggregate: The core logic of this class involved classifying the underlying Aggregator as either an IntegerAggregator or a StringAggregator. Once this was done at constrction time, I went about aggregating the tuples of the child OpIterator by continually calling mergeTupleIntoGroup in a seperate helper function.
- HeapFile / BufferPool Mutability: The biggest challenge with these sections was knowing wheter to write directly to disk or to only modify the BufferPool. This was clarified by looking ahead to flushPage, evictPage, and discardPage.
- Page Eviction: My eviction policy was to remove the page with the smallest tableId and pageNo. This seems arbtrary, but I just wanted to define some sort of consistency for my implementation.
